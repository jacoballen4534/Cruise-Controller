module CruiseSpeedControl:

% Inputs
input Set;
input Speed := 0.0f : float;
input IsInOnState;
input QuickDecel;
input QuickAccel;

% Outputs
output CruiseSpeed : float;

constant Speedinc = 2.5f : float;

function limitSpeed(float) : float;

% FSM encoding:
% state 0 = Disabled,
% state 1 = Active,

var state := 0 : integer in
var temp := 0.00f : float in
emit CruiseSpeed(temp);
loop
    if state = 0 then
        present IsInOnState then
            state := 1;
            temp := limitSpeed(?Speed);
            emit CruiseSpeed(temp);
        end present
    else
        present
        case (not IsInOnState) do %TODO: Add a third state. OFF, InOn(Active) NotInOn(But still active). Only accept Set and Quick commands in the 2 active states. Moving from OFF to InOn will set cruseSpeed to Speed as it is the initial turn on. May need EnableCruiseControl signal again.
            state := 0;
        case Set do
            temp := limitSpeed(?Speed);
            emit CruiseSpeed(temp);
        case (QuickAccel and not QuickDecel) do
            temp := limitSpeed(temp + Speedinc);
            emit CruiseSpeed(temp);
        case (QuickDecel and not QuickAccel) do
            temp := limitSpeed(temp- Speedinc);
            emit CruiseSpeed(temp);
        end present;
    end if;
each tick;
end var;
end var;

end module